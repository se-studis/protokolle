Vorweg, Gerhard ist ein (wie Malte ihn passenderweise genannt hat) â€VerwirrungskÃ¼nstlerâ€œ, aber 
Alex springt ein, wenn man nicht weiterkommt. Und bei mir war ca. 25 Minuten dem Teil Ã¼ber die 
Nicht-freien Datentypen gewidmet. Die Notengebung ist aber sehr nett. 
â€¢ Strukturierte Spezifikationen: 
o Wie geht man da vor? Sorten â€“ Konstruktoren â€“ frei/nicht frei? -> 
ExtensionalitÃ¤tsaxiom 
o Am Beispiel von ungerichtete Graphen: 
â–ª BenÃ¶tigte Sorten: Graph, Knoten, Kanten
â–ª Konstruktoren: Leerer Graph, Kante einfÃ¼gen, Knoten einfÃ¼gen, Kante 
erstellen (eine ungerichtete Kante) 
â€¢ âˆ…, . ++ . âˆ¶ ğ‘”ğ‘Ÿğ‘ğ‘â„ Ã— ğ‘›ğ‘œğ‘‘ğ‘’, . ++. âˆ¶ ğ‘”ğ‘Ÿğ‘ğ‘â„ Ã— ğ‘’ğ‘‘ğ‘”ğ‘’, 
ğ‘šğ‘ğ‘˜ğ‘’ğ¸ğ‘‘ğ‘”ğ‘’: ğ‘›ğ‘œğ‘‘ğ‘’ Ã— ğ‘›ğ‘œğ‘‘ğ‘’
â–ª Tricky: ist das jetzt genug? Ich dachte eigentlich schon, da wir ja damals in 
KIV einfach die Spezifikation Edge angereichert haben und damit alles was 
Kanten betrifft implizit schon vorhanden war â€“ jetzt wollten sie erst Recht, 
dass ich ungerichtete Kanten auch noch definiere.
â–ª ExtensionalitÃ¤t fÃ¼r ungerichtete Kanten: ğ‘’1 = ğ‘’2 â†” âˆ€ğ‘›. ğ‘› âˆˆ ğ‘’1 â†” ğ‘› âˆˆ ğ‘’2
â–ª ğ‘› âˆˆ ğ‘šğ‘ğ‘˜ğ‘’ğ¸ğ‘‘ğ‘”ğ‘’(ğ‘›1, ğ‘›2
) â†” ğ‘› = ğ‘›1 âˆ¨ ğ‘› = ğ‘›2
â–ª Bei der ExtensionalitÃ¤t fÃ¼r den Graphen darf man keinesfalls die Klammern 
vergessen! Sonst bekommt man Ã„rger von Gerhard!
â–ª Frage: Welchem Schema folgt diese Definition jetzt? Es ist nicht nicht-
rekursiv! Zumindest haben die das gesagt, ich glaub es ihnen bis heute nicht.
â–ª Wie schauts aus mit dem Node, muss man da Konstruktoren angeben? -> 
Nein, das ist der Parameter.
â–ª Dann die typische Frage danach, was man jetzt noch machen muss: 
Kongruenz erklÃ¤ren
â–ª Ist das jetzt hierarchiepersistent und eindeutig? 
o Wie kann man jetzt noch definieren? Strukturell-rekursiv, Wohlfundiert (nicht 
noethersch sagen) Rekursiv, Existenz und Eindeutigkeit. 
o Warum ist allgemeine Rekursion schlecht -> kÃ¶nnen nicht sicherstellen, dass es 
terminiert und dann haben wir gar nix spezifiziert
o Deduktion Ã¼ber Programme: Relationale Semantik, warum nicht als Funktion
definieren? -> Indeterminismus, Nicht-Determinismus
o Regeln des SequenzenkalkÃ¼ls fÃ¼r < ğ‘¤â„ğ‘–ğ‘™ğ‘’ ğ‘ ğ‘‘ğ‘œ ğ‘ >
â–ª Was ist das ğ’™ ? Ich habe gesagt, dass es nicht in den freien Variablen auf der 
ganzen Sequenz vorkommen darf (so stehts ja im Skript), aber das ist eine zu 
harte EinschrÃ¤nkung, es darf nur nicht in ğœ“,ğ‘¡, und ğ‘ vorkommen. Bzw. darf
das in ğ‘ sogar vorkommen, solange ğ‘¥ in ğ‘ nicht assigned wird.
o Box und Diamond definieren mithilfe der relationalen Semantik 
o Was gibt es neben der Big-Step Semantik? -> Trace Semantik bzw. Small-Step 
Semantik 
â–ª Und warum brauchen wir die? 
â–ª Ich habe gesagt fÃ¼r Compilerbau und weil es maschinennÃ¤her ist, aber 
irgendwann kam ich drauf, was sie eigentlich hÃ¶ren wollten, dass es ja 
Programme gibt, die nie terminieren (einfache Server-Anwendung, die nie 
aufhÃ¶rt zu laufen -> da sagt uns die Big-Step Semantik nÃ¤mlich gar nicht mal 
so viel â€¦ auch bei verschiedenen Threads ist Big-Step nicht so sinnvoll) 
Dann sagen, was an RS gut und was schlecht ist
â€¢ Schlecht ist das while (erklÃ¤ren was da die Idee ist) und die 
rekursiven Prozeduren (man muss da nÃ¤mlich die Rekursionstiefe
(wichtiges Buzzword) raten)
â€¢ Wer macht das schÃ¶ner? NatÃ¼rliche Semantik 
â€¢ Was ist so viel schÃ¶ner bei der Schleifenregel in NS und wieso kann 
man das in RS nicht so machen? -> Buzzword: Abrollen der Schleife
â€¢ Und dann das Ã¼bliche Gelaber Ã¼ber die FixpunktsÃ¤tze (alles 
hinschreiben kÃ¶nnen, und wissen dass das ğ‘“ dem Hut entspricht), 
also ganz easy und so wie bei Caro, das fÃ¼hre ich hier nicht mehr aus.
â€¢ Wichtig war Gerhard vor allem, dass man ca. 50-mal sagt, dass der 
REC-Operator eine Menge von Tripeln nimmt, darauf Regeln 
anwendet und eine Menge von Tripeln zurÃ¼ckgibt. 
â–ª Ist der NS-Operator immer noch stetig bei Choose? -> Ja
â€¢ Nur der Operator des garantierten Terminierungsbereichs macht da 
Probleme, weil die Choose-Regel ja unendlich viele positive 
PrÃ¤missen haben kann -> Regeloperator nur noch monoton!
â–ª Nichts zu strong diamond 
o Dann noch das Ãœbliche zu Refinements: Wieso braucht man das, wie definiert man 
Kontrakte, was genau ist so ein Ablauf und wie zeigt man, dass eine Verfeinerung 
korrekt ist, Abstraktionsrelation und VorwÃ¤rtssimulation â€¦
â–ª Und was kann man von auÃŸen sehen? -> Input, Operation, Output
â–ª Der Zustand ist unsichtbar
â€¢ Letztlich dann noch eine Runde KIV - Replace: Ein Programm, das alle Vorkommen von ğ‘
durch ğ‘ ersetzt. Gerhard hat ein â€dollesâ€œ Lemma fÃ¼r das Split und hat mir 4 Minuten lang 
erklÃ¤rt was das Programm macht â€¦ Apply Induction â€“ Call Right â€“ Apply Lemma: Split Correct
â€“ dann schaltet der Gerhard Ã¼berraschenderweise die Heuristik ab â€“ Show Goal Again with 
IndHyp â€“ da sieht man dann, dass man in Antezedenz und Sukzedenz fast das gleiche da steht
-> Execute Call â€“ ein paar Assigns und zu is 
Viel Erfolg Euch allen und viel SpaÃŸ ğŸ˜‰